자바


C,C++ 의 포인터랑, 다중상속을 없애버렸어

플랫폼에 독립적이다 (JVM 만 있으면 어디서든지 Linux, Window, Mac )  , jvm 은 자바로 된 프로그램을 실행해주는 것 
Garbage Collector로 사용되지 않는 메모리를 자동적으로 정리해준다.

jdk 
환경 변수 지정 - 새로만들기   이름 : JAVA_HOME    값 : jdk가 설치된 경로    , CLASSPATH, PATH  다  혀 




int [] arr= {10,20,30,40,50}

for(int value: arr){
  System.out.println(value);
}




String 클래스 : new라는 연산자 필요없이 인스턴스를 만들수 있다.  1. String str1 = "hello";, 2.String str2 = "hello" 3.String str3 = new String("hello"); 4.String str4 = new String("hello");
1.은 상수 영역에 저장됨 , 2.는 1이랑 같은것을 가르킨다. 
3. 새로운 인스턴스를 힙 영역에 만들어지게되 4 역시 새로운 인스턴스를 힙 영역에 만들어

if(str1==str2) System.out.println("str1, str2는 같은 레퍼런스"); 




열거형 (특정 값만 가져야 한다면 열거형을 사용하는 것이 좋다.)

class EnumExam{
public static final String MALE="MALE";
public static final String FEMALE ="FEMALE";

String gender1;
gender1 = EnumExam.MALE;
gender1 = "aa" //-> 아무거나 넣어도되  근데 MALE, FEMALE 두개만 넣고싶어  이럴때 열거형을 쓴다


Gender gender2;
gender2 = Gender.MALE;
gender2 = Gender.FEMALE;  

}

enum Gender{
  MALE,FEMALE
}





this (객체 자신을 참조하는 것)(클래스 안에서 자기 자신이 사용하고있는 메소드나, 변수 사용할 때 , 나의 생성자 호출할 때)

public class car{

String name;

   public car(String name){

   name = name  //-> 이렇게 해서  car 객체만들고 name 출력하면 null이 나와
   this.name = name // 이렇게 해야 해 

   }


  public car(){
    this("이름없음",0); //두개의 매개변수를 가진 생성자를 호출
  }

  public car(String name, int number){
   this.name = name;
   this.number = number;
  }

}




패키지 : 서로 관련이 있는 클래스 또는 인터페이스들을 묶어 놓은 묶음. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록
         이름은 도메인 이름을 거꾸로 적은 후 프로젝트 이름을 붙여 사용(겹치지 않게 하기위해)
	 다른 패키지에 있는 클래스를 사용하려면  import를 해야한다. (java.lang 제외하고) ctrl + shift + o 하면 저절로 임포트 




캡슐화 : 관련된 내용을 모아서 가지고 있는 것 , 외부에 감추고 싶은 메소드나 변수가 있을 수도 있어 . -> 접근 제한자를 쓰는거지(public , protected, default, private)

super() -> 부모생성자



클래스의 형변환 : 부모타입이 자식타입을 가리키면  부모가 가진 내용들만 사용 가능하다.  근데 자식꺼 쓰고싶어  그러면 형변환을 하는거야

                   Car c = new Bus();  부모가 더 큰 타입
                   Bus bus = c; -> 오류  작은것은 큰걸 못 가르켜
                   Bus bus =(Bus)c;  -> 이거 가능 자식만의 함수 이런거 다 쓸 수 있어
  
 		   


interface - > java8 부터는 default method 와 static method 구현가능  (원래는 추상메소드만 가능했어)


public interface calculator{

   default int exec(int i,int j){  -> 자식클래스에서 오버라이딩 안해도된다.     ,  메인함수내에서  calculator cal = new MyCal()(자식클래스);    cal.exec(3,4)  하면된다.
         return i+j;
    }

   public static int exec2(int i,int j){    -> 메인함수 내에서 calculator.exec2(3,4) 하면된다.  cal.exec2(3,4); -> 하면안되
          return i*j;
   }
} 




내부클래스 -> 클래스 안에 선언된 클래스 

1.인스턴스 클래스 - 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 클래스를 선언한 경우

public class innerexam1{
   
   class Cal{
     int value = 0;
     public void plus(){ value ++;}
   
      }	


    public static void main(){

	innerexam1 t = new innerexam1();
        innerexam1.Cal cal = t.new Cal();
        cal.plus();	
  }
}


2. static 클래스 - 내부 클래스가 static으로 선언된 경우


public class innerexam1{
   
  static class Cal{
     int value = 0;
     public void plus(){ value ++;}
   
      }	


    public static void main(){
        innerexam1.Cal cal = new innerexam1.Cal();
        cal.plus();	
  }
}

3. 지역클래스  - 메소드 안에 클래스를 선언한 경우


public class innerexam1{
   
 public void exec(){
     class Cal{
        int value = 0;
        public void plus(){ value ++;}
        }

      Cal cal = new Cal();
      cal.plus();
	
  }

    public static void main(){
        innerexam1 t = new innerexam1();
        t.exec();	
  }
}

4. 익명클래스 - 상속받는 클래스를 만들 필요가 없기때문에, 해당클래스에서만 사용되고 다른 클래스에서 사용안하려고


 public abstract class Action{
        public abstract void exec();
    }


  public class ActionExam{
        public static void main(String args[]){
           
	      Action action = new Action(){
                public void exec(){
                    System.out.println("exec");
                }
            };

            action.exec();
        }
    }





throws - Exception 처리를 무시하는것, 호출한 쪽에게 오류를처리하라


public class ExceptionExam2 {

        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            try{
                int k = divide(i, j);
                System.out.println(k);
            } catch(ArithmeticException e){
                System.out.println("0으로 나눌수 없습니다.");
            }

        }

        public static int divide(int i, int j) throws ArithmeticException{
            int k = i / j;
            return k;
        }

    }



throw - 강제로 오류를 발생시키는 것



public class ExceptionExam3 {   
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            try{
                int k = divide(i, j);
                System.out.println(k);
            }catch(IllegalArgumentException e){
                System.out.println(e.toString());
            }           
        }

        public static int divide(int i, int j) throws IllegalArgumentException{
            if(j == 0){
                throw new IllegalArgumentException("0으로 나눌 수 없어요.");
            }
            int k = i / j;
            return k;
        }   
    }




사용자 정의 Exception ,      Exception 클래스를 상속받은 클래스들은 checked Exception 이고 반드시 오류를 처리해야만 해, 예외처리 하지 않으면 컴파일 오류를 발생
                       RuntimeException 클래스를 상속받은 클래스들은 Unchecked Excepton 이고 예외처리를 하지 않아도 컴파일 시에는 오류를 발생시키지 않는다.




public class BizException extends RuntimeException{

  public BizException(String msg){
  	super(msg);   //이렇게만해주면됨  부모클래스 생성자만 정의해주면되  
  }
  
  public BizException(Exception ex){
        super(ex);
  }
}


public class BizService{
  public void bizMethod(int i) throws BizException{
	
	if(i<0){throw new BizException("매개변수 i는 0이상이여야 합니다.")}
		

   }
 }


public class BizExam{

	public static void main(String[] args){
		BizService biz = new BizService();
  		biz.bizMethod(5);
		biz.bizMethod(-3); //예와    - try catch문 해줘두되고 ,  throws를 해줬기때문에 안해줘도되

	}
}







